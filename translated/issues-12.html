    <emu-clause id="sec-touint32" aoid="ToUint32">
      <h1>ToUint32 ( _argument_ )</h1>
      <p>The abstract operation ToUint32 converts _argument_ to one of 2<sup>32</sup> integer values in the range 0 through <emu-eqn>2<sup>32</sup>-1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.
        1. Return _int32bit_.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of ToUint32:</p>
        <ul>
          <li>
            Step 5 is the only difference between ToUint32 and ToInt32.
          </li>
          <li>
            The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.
          </li>
          <li>
            ToUint32(ToInt32(_x_)) is equal to ToUint32(_x_) for all values of _x_. (It is to preserve this latter property that *+&infin;* and *-&infin;* are mapped to *+0*.)
          </li>
          <li>
            ToUint32 maps *-0* to *+0*.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <!-- es6num="7.1.7" -->
    <emu-clause id="sec-toint16" aoid="ToInt16">
      <h1>ToInt16 ( _argument_ )</h1>
      <p>The abstract operation ToInt16 converts _argument_ to one of 2<sup>16</sup> integer values in the range -32768 through 32767, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.
        1. If _int16bit_ &ge; 2<sup>15</sup>, return _int16bit_ - 2<sup>16</sup>; otherwise return _int16bit_.
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.1.8" -->
    <emu-clause id="sec-touint16" aoid="ToUint16">
      <h1>ToUint16 ( _argument_ )</h1>
      <p>The abstract operation ToUint16 converts _argument_ to one of 2<sup>16</sup> integer values in the range 0 through <emu-eqn>2<sup>16</sup>-1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.
        1. Return _int16bit_.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of ToUint16:</p>
        <ul>
          <li>
            The substitution of 2<sup>16</sup> for 2<sup>32</sup> in step 4 is the only difference between ToUint32 and ToUint16.
          </li>
          <li>
            ToUint16 maps *-0* to *+0*.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <!-- es6num="7.1.9" -->
    <emu-clause id="sec-toint8" aoid="ToInt8">
      <h1>ToInt8 ( _argument_ )</h1>
      <p>The abstract operation ToInt8 converts _argument_ to one of 2<sup>8</sup> integer values in the range -128 through 127, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.
        1. If _int8bit_ &ge; 2<sup>7</sup>, return _int8bit_ - 2<sup>8</sup>; otherwise return _int8bit_.
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.1.10" -->
    <emu-clause id="sec-touint8" aoid="ToUint8">
      <h1>ToUint8 ( _argument_ )</h1>
      <p>The abstract operation ToUint8 converts _argument_ to one of 2<sup>8</sup> integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.
        1. Return _int8bit_.
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.1.11" -->
    <emu-clause id="sec-touint8clamp" aoid="ToUint8Clamp">
      <h1>ToUint8Clamp ( _argument_ )</h1>
      <p>The abstract operation ToUint8Clamp converts _argument_ to one of 2<sup>8</sup> integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _number_ be ? ToNumber(_argument_).
        1. If _number_ is *NaN*, return *+0*.
        1. If _number_ &le; 0, return *+0*.
        1. If _number_ &ge; 255, return 255.
        1. Let _f_ be floor(_number_).
        1. If _f_ + 0.5 &lt; _number_, return _f_ + 1.
        1. If _number_ &lt; _f_ + 0.5, return _f_.
        1. If _f_ is odd, return _f_ + 1.
        1. Return _f_.
      </emu-alg>
      <emu-note>
        <p>Unlike the other ECMAScript integer conversion abstract operation, ToUint8Clamp rounds rather than truncates non-integer values and does not convert *+&infin;* to 0. ToUint8Clamp does &ldquo;round half to even&rdquo; tie-breaking. This differs from `Math.round` which does &ldquo;round half up&rdquo; tie-breaking.</p>
      </emu-note>
    </emu-clause>

    <!-- es6num="7.1.12" -->
    <emu-clause id="sec-tostring" aoid="ToString">
      <h1>ToString ( _argument_ )</h1>
      <p>The abstract operation ToString converts _argument_ to a value of type String according to <emu-xref href="#table-12"></emu-xref>:</p>
      <emu-table id="table-12" caption="ToString Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Return `"undefined"`.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Return `"null"`.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              <p>If _argument_ is *true*, return `"true"`.</p>
              <p>If _argument_ is *false*, return `"false"`.</p>
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return NumberToString(_argument_).
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              <p>Apply the following steps:</p>
              <emu-alg>
                1. Let _primValue_ be ? ToPrimitive(_argument_, hint String).
                1. Return ? ToString(_primValue_).
              </emu-alg>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <!-- es6num="7.1.12.1" -->
      <emu-clause id="sec-tostring-applied-to-the-number-type" aoid="NumberToString">
        <h1>NumberToString ( _m_ )</h1>
        <p>The abstract operation NumberToString converts a Number _m_ to String format as follows:</p>
        <emu-alg>
          1. If _m_ is *NaN*, return the String `"NaN"`.
          1. If _m_ is *+0* or *-0*, return the String `"0"`.
          1. If _m_ is less than zero, return the string-concatenation of `"-"` and ! ToString(-_m_).
          1. If _m_ is *+&infin;*, return the String `"Infinity"`.
          1. Otherwise, let _n_, _k_, and _s_ be integers such that _k_ &ge; 1, 10<sup>_k_-1</sup> &le; _s_ &lt; 10<sup>_k_</sup>, the Number value for _s_ &times; 10<sup>_n_-_k_</sup> is _m_, and _k_ is as small as possible. Note that _k_ is the number of digits in the decimal representation of _s_, that _s_ is not divisible by 10, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.
          1. If _k_ &le; _n_ &le; 21, return the string-concatenation of:
            * the code units of the _k_ digits of the decimal representation of _s_ (in order, with no leading zeroes)
            * _n_-_k_ occurrences of the code unit 0x0030 (DIGIT ZERO)
          1. If 0 &lt; _n_ &le; 21, return the string-concatenation of:
            * the code units of the most significant _n_ digits of the decimal representation of _s_
            * the code unit 0x002E (FULL STOP)
            * the code units of the remaining _k_-_n_ digits of the decimal representation of _s_
          1. If -6 &lt; _n_ &le; 0, return the string-concatenation of:
            * the code unit 0x0030 (DIGIT ZERO)
            * the code unit 0x002E (FULL STOP)
            * -_n_ occurrences of the code unit 0x0030 (DIGIT ZERO)
            * the code units of the _k_ digits of the decimal representation of _s_
          1. Otherwise, if _k_ = 1, return the string-concatenation of:
            * the code unit of the single digit of _s_
            * the code unit 0x0065 (LATIN SMALL LETTER E)
            * the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether _n_-1 is positive or negative
            * the code units of the decimal representation of the integer abs(_n_-1) (with no leading zeroes)
          1. Return the string-concatenation of:
            * the code units of the most significant digit of the decimal representation of _s_
            * the code unit 0x002E (FULL STOP)
            * the code units of the remaining _k_-1 digits of the decimal representation of _s_
            * the code unit 0x0065 (LATIN SMALL LETTER E)
            * the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether _n_-1 is positive or negative
            * the code units of the decimal representation of the integer abs(_n_-1) (with no leading zeroes)
        </emu-alg>
        <emu-note>
          <p>The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:</p>
          <ul>
            <li>
              If x is any Number value other than *-0*, then ToNumber(ToString(x)) is exactly the same Number value as x.
            </li>
            <li>
              The least significant digit of s is not always uniquely determined by the requirements listed in step 5.
            </li>
          </ul>
        </emu-note>
        <emu-note>
          <p>For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step 5 be used as a guideline:</p>
          <emu-alg>
            5. Otherwise, let _n_, _k_, and _s_ be integers such that _k_ &ge; 1, 10<sup>_k_-1</sup> &le; _s_ &lt; 10<sup>_k_</sup>, the Number value for _s_ &times; 10<sup>_n_-_k_</sup> is _m_, and _k_ is as small as possible. If there are multiple possibilities for _s_, choose the value of _s_ for which _s_ &times; 10<sup>_n_-_k_</sup> is closest in value to _m_. If there are two such possible values of _s_, choose the one that is even. Note that _k_ is the number of digits in the decimal representation of _s_ and that _s_ is not divisible by 10.
          </emu-alg>
        </emu-note>
        <emu-note>
          <p>Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:</p>
          <p>Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). November 30, 1990. Available as
            <br>
            <a href="http://ampl.com/REFS/abstracts.html#rounding">http://ampl.com/REFS/abstracts.html#rounding</a>. Associated code available as
            <br>
            <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> and as
            <br>
            <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a> and may also be found at the various `netlib` mirror sites.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <!-- es6num="7.1.13" -->
    <emu-clause id="sec-toobject" aoid="ToObject">
      <h1>ToObject ( _argument_ )</h1>
      <p>The abstract operation ToObject converts _argument_ to a value of type Object according to <emu-xref href="#table-13"></emu-xref>:</p>
      <emu-table id="table-13" caption="ToObject Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return a new Boolean object whose [[BooleanData]] internal slot is set to _argument_. See <emu-xref href="#sec-boolean-objects"></emu-xref> for a description of Boolean objects.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return a new Number object whose [[NumberData]] internal slot is set to _argument_. See <emu-xref href="#sec-number-objects"></emu-xref> for a description of Number objects.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Return a new String object whose [[StringData]] internal slot is set to _argument_. See <emu-xref href="#sec-string-objects"></emu-xref> for a description of String objects.
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Return a new Symbol object whose [[SymbolData]] internal slot is set to _argument_. See <emu-xref href="#sec-symbol-objects"></emu-xref> for a description of Symbol objects.
            </td>
          </tr>
          <tr>
            <td>
              Object
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <!-- es6num="7.1.14" -->
    <emu-clause id="sec-topropertykey" aoid="ToPropertyKey">
      <h1>ToPropertyKey ( _argument_ )</h1>
      <p>The abstract operation ToPropertyKey converts _argument_ to a value that can be used as a property key by performing the following steps:</p>
      <emu-alg>
        1. Let _key_ be ? ToPrimitive(_argument_, hint String).
        1. If Type(_key_) is Symbol, then
          1. Return _key_.
        1. Return ! ToString(_key_).
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.1.15" -->
    <emu-clause id="sec-tolength" aoid="ToLength">
      <h1>ToLength ( _argument_ )</h1>
      <p>The abstract operation ToLength converts _argument_ to an integer suitable for use as the length of an array-like object. It performs the following steps:</p>
      <emu-alg>
        1. Let _len_ be ? ToInteger(_argument_).
        1. If _len_ &le; *+0*, return *+0*.
        1. Return min(_len_, 2<sup>53</sup>-1).
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.1.16" -->
    <emu-clause id="sec-canonicalnumericindexstring" aoid="CanonicalNumericIndexString">
      <h1>CanonicalNumericIndexString ( _argument_ )</h1>
      <p>The abstract operation CanonicalNumericIndexString returns _argument_ converted to a numeric value if it is a String representation of a Number that would be produced by ToString, or the string `"-0"`. Otherwise, it returns *undefined*. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Assert: Type(_argument_) is String.
        1. If _argument_ is `"-0"`, return *-0*.
        1. Let _n_ be ! ToNumber(_argument_).
        1. If SameValue(! ToString(_n_), _argument_) is *false*, return *undefined*.
        1. Return _n_.
      </emu-alg>
      <p>A <em>canonical numeric string</em> is any String value for which the CanonicalNumericIndexString abstract operation does not return *undefined*.</p>
    </emu-clause>

    <emu-clause id="sec-toindex" aoid="ToIndex">
      <h1>ToIndex ( _value_ )</h1>
      <p>The abstract operation ToIndex returns _value_ argument converted to a numeric value if it is a valid integer index value. This abstract operation functions as follows:</p>
      <emu-alg>
        1. If _value_ is *undefined*, then
          1. Let _index_ be 0.
        1. Else,
          1. Let _integerIndex_ be ? ToInteger(_value_).
          1. If _integerIndex_ &lt; 0, throw a *RangeError* exception.
          1. Let _index_ be ! ToLength(_integerIndex_).
          1. If SameValueZero(_integerIndex_, _index_) is *false*, throw a *RangeError* exception.
        1. Return _index_.
      </emu-alg>
    </emu-clause>
  </emu-clause>