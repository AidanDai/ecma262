<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1><abbr title="ECMAScript Data Types and Values">ECMAScript 数据类型和值</abbr></h1>
  <p>本规范中算法操作每个具有相关类型的值。可能的值类型直接定义在本章节中。这些类型进一步分为 ECMAScript 语言类型与规范类型。</p>
  <p>在本规范中，&ldquo;Type(_x_)&rdquo;表示法是&ldquo;the <dfn id="type">type</dfn> of _x_&rdquo;的简写， 其中&ldquo;type&rdquo;指的是在本章节中定义的 ECMAScript 语言类型与规范类型。当一个值使用术语&ldquo;empty&rdquo;命名值时，它相当于说&ldquo;没有任何类型的值(no value of any type)&rdquo;。</p>
  <!-- es6num="6.1" -->
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript 语言类型</h1>
    <p>一个 <dfn>ECMAScript 语言类型</dfn>对应那些 ECMAScript 程序员在 ECMAScript 语言中直接使用的值。 ECMAScript 语言类型有 Undefined, Null, Boolean, String,Symbol, Number, Object。 一个<dfn>ECMAScript 语言值</dfn>是指拥有 ECMAScript 语言类型特点的值。</p>

    <!-- es6num="6.1.1" -->
    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>Undefined 类型</h1>
      <p>Undefined 类型仅仅只有一个值，`undefined`。 任何尚未分配值的变量值都为 `undefined`。</p>
    </emu-clause>

    <!-- es6num="6.1.2" -->
    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>Null 类型</h1>
      <p>Null 类型只有一个值, `null`.</p>
    </emu-clause>

    <!-- es6num="6.1.3" -->
    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>Boolean 类型</h1>
      <p>Boolean 类型表示具有 `true` 和 `false` 两个值的逻辑实体。</p>
    </emu-clause>

    <!-- es6num="6.1.4" -->
    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>String 类型</h1>
      <p>String 类型是零个或多个 16 位无符号整数值（&ldquo;元素&rdquo;）的所有有序序列的集合，最大长度为 2<sup>53</sup>-1 个元素。字符串类型通常用于表示正在运行的 ECMAScript 程序中的文本数据，在这种情况下，String中的每个元素都被视为一个 UTF-16 <abbr title="code unit">码元</abbr>。 每个元素被认为占据该序列内的一个位置。 这些位置用非负整数索引。 第一个元素（如果有）在索引 0 处，下一个元素（如果有的话）在索引 1 处，以此类推。 String 的长度是序列中的元素个数（即 16-bit 值）。空字符串的长度为零，因此不包含元素。</p>
      <p>ECMAScript 操作在解释字符串值时，每个元素都被认为是一个单独的 UTF-16 码元。但是，ECMAScript 对 String 值中的码元序列没有任何限制或要求，因此当按照 UTF-16 码元序列解释时， 它们可能是<abbr title="ill-formed">不正确</abbr>的。（因为）不解释字符串内容的操作将它们当做无差别的 16-bit 无符号整数序列。可以使用函数 `String.prototype.normalize` (见<emu-xref href="#sec-string.prototype.normalize"></emu-xref>)显式的把一个 String 值标准化。 `String.prototype.localeCompare`(见<emu-xref href="#sec-string.prototype.localecompare"></emu-xref>) 方法在函数内部（隐式地）标准化了 String 值，除此之外的其它方法都没有隐式地标准化字符串。 只有明确指定语言或区域敏感的操作才会产生语言敏感的结果。</p>
      <emu-note>
        <p>这种设计背后的理由是尽可能的保持 String 的实现简单和高效。 如果 ECMAScript 源文本符合 Normalized Form C，只要它们不包含任何 Unicode 转义序列，则字符串字面量保证也是标准化的。</p>
      </emu-note>
      <p>一些操作将字符串内容解释为 UTF-16 编码的 Unicode 码点。 在这种情况下，解释过程是：</p>
      <ul>
        <li>
          在范围 0 到 0xD7FF 或 0xE000 到 0xFFFF 范围内的码元被解释为具有相同值的码点。
        </li>
        <li>
          两个码元，第一个码元 _c1_ 范围为 0xD800 到 0xDBFF，第二个码元 _c2_ 范围为 0xDC00 到 0xDFFF， 这样的两个码元，被称为<attr title="surrogate pair">代理对</attr>， 被解释为一个值为 (_c1_ - 0xD800) &times; 0x400 + (_c2_ - 0xDC00) + 0x10000 的码点。
        </li>
        <li>
          一个在 0xD800 到 0xDFFF 范围内，但不是代理对的一部分的码元被解释为具有相同值的码点。
        </li>
      </ul>
      <p>在本规范中，短语"the string-concatenation of _A_,_B_,..."表示字符串代码单元的序列是每个参数的代码单元的连接。</p>
    </emu-clause>

    <!-- es6num="6.1.5" -->
    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>Symbol 类型</h1>
      <p>Symbol 类型是所有可以用于作为 Object 属性的 key 的非字符串值的集合。(<emu-xref href="#sec-object-type"></emu-xref>).</p>
      <p>每个可能的 Symbol 值都是唯一的和不可变的。</p>
      <p>每个 Symbol 值永远地保持一个与之关联的叫做 [[Description]] 的值（它要么是 undefined 要么是一个 String 值）。</p>

      <!-- es6num="6.1.5.1" -->
      <emu-clause id="sec-well-known-symbols">
        <h1>著名 Symbol</h1>
        <p>著名 Symbol 是那些被本规范中算法明确引用的内置 Symbol 值。它们通常被用作属性的 key，这些 key 的值为规范的算法提供了一种扩展。除非另有说明，著名 Symbol 的值被所有域(<emu-xref href="#sec-code-realms"></emu-xref>)共享。</p>
        <p>在本规范内，一个著名 Symbol 值通过形如 form@@name 的形式被引用，这里的 &ldquo;name&rdquo; 是表 <emu-xref href="#table-1"></emu-xref> 列出的值之一。</p>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
              <tr>
                <th>
                  名称
                </th>
                <th>
                  [[Description]]
                </th>
                <th>
                  值和目的
                </th>
              </tr>
              <tr>
                <td>
                  @@hasInstance
                </td>
                <td>
                  `"Symbol.hasInstance"`
                </td>
                <td>
                  确定构造函数对象是否识别对象为构造函数实例之一的方法。由 `instanceof` 运算符语义来调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@isConcatSpreadable
                </td>
                <td>
                  `"Symbol.isConcatSpreadable"`
                </td>
                <td>
                  一个Boolean值，如果为 true， 表示一个对象应该被 <emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref> 扁平化的加入到元素中。
                </td>
              </tr>
              <tr>
                <td>
                  @@iterator
                </td>
                <td>
                  `"Symbol.iterator"`
                </td>
                <td>
                  返回一个对象的默认 Iterator 的方法。由 for-of 声明的语义来调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@match
                </td>
                <td>
                  `"Symbol.match"`
                </td>
                <td>
                  将字符串与正则表达式匹配的正则表达式方法。 由 <emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref> 方法调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@replace
                </td>
                <td>
                  `"Symbol.replace"`
                </td>
                <td>
                  替换匹配字符串子串的正则表达式方法。 由 <emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref> 方法调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@search
                </td>
                <td>
                  `"Symbol.search"`
                </td>
                <td>
                  一个正则表达式方法，它返回正则表达式匹配到在字符串中的索引。 由<emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref>方法调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@species
                </td>
                <td>
                  `"Symbol.species"`
                </td>
                <td>
                  作为构造函数的函数值属性，用来创建派生对象。
                </td>
              </tr>
              <tr>
                <td>
                  @@split
                </td>
                <td>
                  `"Symbol.split"`
                </td>
                <td>
                  一个正则表达式方法，它在正则表达式匹配的索引位置拆分字符串。 由 <emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref> 方法调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@toPrimitive
                </td>
                <td>
                  `"Symbol.toPrimitive"`
                </td>
                <td>
                  将一个对象转换为相应原始值的方法。由抽象操作 ToPrimitive 调用。
                </td>
              </tr>
              <tr>
                <td>
                  @@toStringTag
                </td>
                <td>
                  `"Symbol.toStringTag"`
                </td>
                <td>
                  一个字符串值属性，用于表示对象在创建时的默认字符串描述。通过内置方法 <emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref> 访问。
                </td>
              </tr>
              <tr>
                <td>
                  @@unscopables
                </td>
                <td>
                  `"Symbol.unscopables"`
                </td>
                <td>
                  一个对象值属性，其自身和继承的属性名是从相关对象非在 `with` 环境绑定的属性名。
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <!-- es6num="6.1.6" -->
    <emu-clause id="sec-ecmascript-language-types-number-type">
      <h1>Number 类型</h1>
      <p>Number 类型有 18437736874454810627 (即，<emu-eqn>2<sup>64</sup>-2<sup>53</sup>+3</emu-eqn>)个值，表示双精度 64 位格式的 IEEE 754-2008 值由 IEEE 二进制浮点数标准规定，除了 9007199254740990 (即，<emu-eqn>2<sup>53</sup>-2</emu-eqn>)这个在 IEEE 标准中独特的 &ldquo;Not-a-Number&rdquo; 值，其在 ECMAScript 中表示为一个特殊的 `NaN` 值。(注意 `NaN` 值在程序中由 `NaN` 表达式产生)在某些实现中，外部代码可能能够检测各种 Not-a-Number 值之间的差异，但这种行为依赖于实现; 对于 ECMAScript 代码，所有的 `NaN` 值彼此是不可区分。</p>
      <emu-note>
        <p>一个可被观察的 ArrayBuffer(见<emu-xref href="#sec-arraybuffer-objects"></emu-xref>) 或 SharedArrayBuffer(见<emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>) 中存入一个Number值之后的位模式没有必要与 ECMAScript 实现内部代表的 Number 值相同。</p>
      </emu-note>
      <p>还有另外两个特殊的值，叫做<abbr title="positive Infinity">*正无穷*</abbr>和<abbr title="*negative Infinity*">*负无穷*</abbr>。 为了简洁起见，这些值分别由符号 `+&infin;` 和 `-&infin;` 表示。（请注意，这两个无限数值由程序表达式 `+Infinity`（或 `Infinity` ）和 `-Infinity` 产生。）</p>
      <p>除了 3 个特殊值，其他 18437736874454810624（即，<emu-eqn>2<sup>64</sup>-2<sup>53</sup></emu-eqn>）个值称为有限值。 其中一半为正数，一般为负数；每个有限正数存在相同大小的对应负数。</p>
      <p>注意其中有一个*正零*，一个*负零*。为了简洁，他们也分别用 `+0` 和 `-0` 来说明。（注意这两个不同的 0，通过程序表达式 `+0`(或 `0`) 和 `-0` 产生。）</p>
      <p>18437736874454810622（即 <emu-eqn>2<sup>64</sup>-2<sup>53</sup>-2</emu-eqn>）个有限非 0 值有两种：</p>
      <p>其中 18428729675200069632 (即 <emu-eqn>2<sup>64</sup>-2<sup>54</sup></emu-eqn>) 个值是标准的, 具有如下格式</p>
      <div class="math-display">
        _s_ &times; _m_ &times; 2<sup>_e_</sup>
      </div>
      <p>其中 _s_ 为 +1 或 -1，_m_ 是一个小于 2<sup>53</sup> 大于等于 2<sup>52</sup> 的整数，_e_ 是从 -1074 到 971 的整数。</p>
      <p>其余 9007199254740990 (即 <emu-eqn>2<sup>53</sup>-2</emu-eqn>) 个值是非标准的, 有如下格式</p>
      <div class="math-display">
        _s_ &times; _m_ &times; 2<sup>_e_</sup>
      </div>
      <p>其中 s 是 +1 或 -1 ，m 是小于 52 的正整数，e 是 -1074。</p>
      <p>注意，大小不大于 2<sup>53</sup> 的所有正整数和负整数可以在数字类型中表示（实际上，整数 0 具有两个表示，`+0` 和 `-0`）。</p>
      <p>如果一个有限的数值非零且用来表达它（上文两种形式之一）的整数 m 是奇数，则该数值有<em><abbr title="odd significand">奇数意义</abbr></em>。否则，它有<em><abbr title="even significand">偶数意义</abbr></em>。</p>
      <p>在本规范中，当 _x_ 表示一个精确的非零实数数学量（甚至可以是无理数，比如&pi;）时，&ldquo;the Number value for _x_&rdquo; 意为，以下面的方式选择一个 Number 值。考虑 Number 类型中除了 `-0` 和两个被加入在数值类型中但不可呈现的值，2<sup>1024</sup> (<emu-eqn>+1 &times; 2<sup>53</sup> &times; 2<sup>971</sup></emu-eqn>) 以及 <emu-eqn>-2<sup>1024</sup></emu-eqn>(<emu-eqn>-1 &times; 2<sup>53</sup> &times; 2<sup>971</sup></emu-eqn>)的所有有限值的集合。选择此集合中值最接近 _x_ 的一员。若集合中的两值近似相等，那么选择有偶数意义的那个；为此，2<sup>1024</sup>和<emu-eqn>-2<sup>1024</sup></emu-eqn>这两个超额值被认为有偶数意义。最终，若选择 2<sup>1024</sup> ，用 `+&infin;` 替换它；若选择 <emu-eqn>-2<sup>1024</sup></emu-eqn>， 用 `-&infin;` 替换它；若选择 `+0`，有且只有 _x_ 小于零时，用 `-0` 替换它；其它任何被选取的值都不用改变。结果就是 _x_ 的数字值。（此过程正是IEEE 754-2008&ldquo;round to nearest, ties to even&rdquo;模式对应的行为。）</p>
      <p>某些 ECMAScript 运算符仅处理闭区间 <emu-eqn>-2<sup>31</sup></emu-eqn> 到 <emu-eqn>2<sup>31</sup>-1</emu-eqn>，或者 0 到 <emu-eqn>2<sup>16</sup>-1</emu-eqn> 的整数。 这些操作符接收任意 Number 类型的值，首先会将它们转换成像上面提到的这些范围内的值。参考<emu-xref href="#sec-type-conversion"></emu-xref>的数字转换操作。</p>
    </emu-clause>

    <!-- es6num="6.1.7" -->
    <emu-clause id="sec-object-type">
      <h1>Object 类型</h1>
      <p>对象在逻辑上是属性的集合。每个属性都是一个数据属性或一个访问器属性：</p>
      <ul>
        <li>
          <em>数据属性</em>关联 key 值和一个 ECMAScript 语言值以及一组值为 Boolean 类型的特性。
        </li>
        <li>
          <em>访问器属性</em>关联 key 值和一个或两个访问器函数以及一组值为 Boolean 类型的特性。访问器函数用于存储或检索与属性相关联的 ECMAScript 语言值。
        </li>
      </ul>
      <p>属性使用 key 值来标识。一个属性的 key 值是 ECMAScript String 值或 Symbol 值。所有 String 值（包括空字符串） 和 Symbol 值作为属性的 key 都是有效的。一个属性的 key 为 String 值时，<em>属性名称</em>为属性的 key 。</p>
      <p>一个值为 `+0` 或者一个 &le; 2<sup>53</sup>-1 的整数作为属性 key 字符串值的<em>整数索引</em>是一个以典型的数字 String。 一个<dfn id="array-index">数组索引</dfn>是范围在 <emu-eqn>+0 &le; _i_ &lt; 2<sup>32</sup>-1</emu-eqn> 的整数。</p>
      <p>属性的 key 用来访问属性以及其值。属性有两种访问方式：<em>get</em> 和 <em>set</em> ，分别对应值的检索和赋值。通过 get 和 set 可访问的属性既包括直接属于的<em>自身属性</em>，也包括通过继承关系由其它相关对象提供的<em>继承属性</em>。继承属性也可能是另一个对象的自身属性或者继承属性。对象的每个自身属性必须有一个与对象的其他自身属性 key 值不同 key 值。</p>
      <p>所有的对象都是逻辑上的属性集合，但是在用于访问和操纵它们的属性的语义中存在多种形式的对象。<em>普通对象</em>是对象的最常见形式，拥有默认的对象语义。<em>奇异对象</em>是指其属性语义与默认语义的各个方面都有区别的对象。</p>

      <!-- es6num="6.1.7.1" -->
      <emu-clause id="sec-property-attributes">
        <h1><abbr title="Property Attributes">属性特性</abbr></h1>
        <p>在本规范中特性用来定义和解释对象属性的状态。数据属性关联表<emu-xref href="#table-2"></emu-xref>中列出的一个 key 值的特性。</p>
        <emu-table id="table-2" caption="Attributes of a Data Property">
          <table>
            <tbody>
              <tr>
                <th>
                  特性名称
                </th>
                <th>
                  值域
                </th>
                <th>
                  描述
                </th>
              </tr>
              <tr>
                <td>
                  [[Value]]
                </td>
                <td>
                  任何 ECMAScript 语言类型
                </td>
                <td>
                  get 访问检索到的属性值
                </td>
              </tr>
              <tr>
                <td>
                  [[Writable]]
                </td>
                <td>
                  Boolean
                </td>
                <td>
                  如果为 *false*，尝试通过 [[Set]] 去改变属性的 [[Value]] 特性的 ECMAScript 代码将不会成功。
                </td>
              </tr>
              <tr>
                <td>
                  [[Enumerable]]
                </td>
                <td>
                  Boolean
                </td>
                <td>
                  如果为 *true*, 这个属性被 for-in 枚举时将会是可枚举的(见<emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>)。否则，这个属性就是不可枚举的。
                </td>
              </tr>
              <tr>
                <td>
                  [[Configurable]]
                </td>
                <td>
                  Boolean
                </td>
                <td>
                  如果为 *false*，尝试删除这个属性，把这个属性改为访问器属性，或者改变它的的特性(除了修改 [[Value]]，或修改 [[Writable]] 为 false 之外)都会失败。
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
        <p>
          访问器属性关联表<emu-xref href="#table-3"></emu-xref>中的列出一个值。
        </p>
        <emu-table id="table-3" caption="Attributes of an Accessor Property">
          <table>
            <tbody>
              <tr>
                <th>
                  特性名称
                </th>
                <th>
                  值域
                </th>
                <th>
                  描述
                </th>
              </tr>
              <tr>
                <td>
                  [[Get]]
                </td>
                <td>
                  Object | Undefined
                </td>
                <td>
                  如果这个值是一个对象，那么它必须是一个函数对象。在每次取值(get 访问该属性被执行)时，这个函数的内部 [[Call]] 方法(<emu-xref href="#table-6"></emu-xref>)将会以一个空 arguments 列表调用获取属性值。
                </td>
              </tr>
              <tr>
                <td>
                  [[Set]]
                </td>
                <td>
                  Object | Undefined
                </td>
                <td>
                  如果这个值是一个对象，那么它必须是一个函数对象。在每次赋值(set 访问该属性被执行)时，这个函数的内部 [[Call]] 方法(<emu-xref href="#table-6"></emu-xref>)将会以一个包含分配的值为参数的 arguments 调用。内部方法 [[Set]] 应该会对后续的内部方法 [[Get]] 调用产生的返回值产生影响，但不是必须的。
                </td>
              </tr>
              <tr>
                <td>
                  [[Enumerable]]
                </td>
                <td>
                  Boolean
                </td>
                <td>
                  如果为 *true*,这个属性被 for-in 枚举时将会是可枚举的(见<emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>)。 否则，这个属性就是不可枚举的。
                </td>
              </tr>
              <tr>
                <td>
                  [[Configurable]]
                </td>
                <td>
                  Boolean
                </td>
                <td>
                  如果为 *false*，任何尝试删除这个属性，把这个属性改为数据属性，或者改变它的其它特性的操作都会失败。
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
        <p>如果一个属性的特性的初始值没有被本规范显式地指定的，那么使用在表<emu-xref href="#table-4"></emu-xref>中定义的默认值。</p>
        <emu-table id="table-4" caption="Default Attribute Values">
          <table>
            <tbody>
              <tr>
                <th>
                  特性名
                </th>
                <th>
                  默认值
                </th>
              </tr>
              <tr>
                <td>
                  [[Value]]
                </td>
                <td>
                  *undefined*
                </td>
              </tr>
              <tr>
                <td>
                  [[Get]]
                </td>
                <td>
                  *undefined*
                </td>
              </tr>
              <tr>
                <td>
                  [[Set]]
                </td>
                <td>
                  *undefined*
                </td>
              </tr>
              <tr>
                <td>
                  [[Writable]]
                </td>
                <td>
                  *false*
                </td>
              </tr>
              <tr>
                <td>
                  [[Enumerable]]
                </td>
                <td>
                  *false*
                </td>
              </tr>
              <tr>
                <td>
                  [[Configurable]]
                </td>
                <td>
                  *false*
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <!-- es6num="6.1.7.2" -->
      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>对象的<abbr title="Internal Methods">内部方法</abbr>以及<abbr title="Internal Slots">内部槽</abbr></h1>
        <p>在 ECMAScript 中，对象的实际语义是通过算法来调用<em>内部方法</em>指定的。在 ECMAScript 引擎中的每个对象都与一系列的定义它的运行时行为的内部方法相关联。这些内部方法不属于 ECMAScript 语言的一部分。本规范定义它们纯粹是为了说明目的。但是，在 ECMAScript 具体实现中的每个对象必须表现得与其相关关联的内部方法一致。其中确切的方式由实现者来决定。</p>
        <p>内部方法名称是多态的。这意味着当一个通用内部方法被调用的时候，不同的对象值可能会执行不同的算法。调用内部方法实际的对象是这个调用 &ldquo;target&rdquo;。如果在运行时，实现的算法尝试使用一个对象不支持的内部方法，抛出一个`TypeError`异常。</p>
        <p>内部槽对应于相关对象的内部状态，用于各种 ECMAScript 规范算法。内部槽不是对象的属性，也不会被继承。根据具体的内部槽规范，内部状态可能由任意 ECMAScript 语言类型的值或者指定的 ECMAScript 规范类型的值组成。除非另有指定，否则分配内部槽应作为创建一个对象的过程的部分，并且不应该动态地添加到对象上。除非另有指定，否则一个内部槽的初始值是 *undefined*。本规范内很多算法都会创建有内部槽的对象。然而，ECMAScript 语言不提供直接去访问一个对象内部槽的方法。</p>
        <p>本规范内的内部方法和内部槽使用闭合的双方括号 [[]] 来标识。</p>
        <p>表 <emu-xref href="#table-5"></emu-xref> 总结了本规范中适用于所有通过 ECMAScript 代码创建或者操作的对象的<em><abbr title="essential internal methods">基本内部方法</abbr></em>。每个对象必须有所有基本内部方法的算法。不过，对于那些方法不必所有的对象都用一样的算法。</p>
        <p>表 <emu-xref href="#table-5"></emu-xref> 中的 &ldquo;Signature&rdquo; 列以及其它相似的表格描述了每个内部方法的调用模式。调用模式总是包含一个括起来的描述参数名的列表。如果一个参数名与 ECMAScript 类型的名字一样，则该名称描述了参数值的所需类型。如果一个内部方法显式地返回了一个值，则它的参数列表接着是一个 &ldquo;&rarr;&rdquo; 符号，以及返回值的类型名称。 在 &ldquo;Signature&rdquo; 列中使用的类型名称指向在<emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>中定义的类型，以及一些附加的名称。 &ldquo;<em>any</em>&rdquo; 意味着这个值可以是任意的 ECMAScript 语言值。一个内部方法会隐式地返回一个 Completion Record。 除了它的参数，一个内部方法还总会访问调用这个方法的目标对象。</p>
        <emu-table id="table-5" caption="Essential Internal Methods">
          <table>
            <tbody>
              <tr>
                <th>
                  Internal Method
                </th>
                <th>
                  Signature
                </th>
                <th>
                  Description
                </th>
              </tr>
              <tr>
                <td>
                  [[GetPrototypeOf]]
                </td>
                <td>
                  ( ) <b>&rarr;</b> Object | Null
                </td>
                <td>
                  确定为对象提供继承属性的对象。*null* 值表示没有继承属性。
                </td>
              </tr>
              <tr>
                <td>
                  [[SetPrototypeOf]]
                </td>
                <td>
                  (Object | Null) <b>&rarr;</b> Boolean
                </td>
                <td>
                  关联这个对象与提供继承属性的对象。传递 *null* 表示没有继承属性。返回 true 表示操作成功完成，返回 false 表示操作失败。
                </td>
              </tr>
              <tr>
                <td>
                  [[IsExtensible]]
                </td>
                <td>
                  ( ) <b>&rarr;</b> Boolean
                </td>
                <td>
                  决定是否允许添加额外的属性到这个对象上。
                </td>
              </tr>
              <tr>
                <td>
                  [[PreventExtensions]]
                </td>
                <td>
                  ( ) <b>&rarr;</b> Boolean
                </td>
                <td>
                  控制一个新的属性是否能加到这个对象上。返回 true 表示操作成功，返回 false 表示操作失败。
                </td>
              </tr>
              <tr>
                <td>
                  [[GetOwnProperty]]
                </td>
                <td>
                  (_propertyKey_) <b>&rarr;</b> Undefined | Property Descriptor
                </td>
                <td>
                  返回对象自身属性中 key 值为 _propertyKey_ 的属性的<abbr title="Property Descriptor">属性描述符</abbr>，如果没有这个属性返回`undefined`。
                </td>
              </tr>
              <tr>
                <td>
                  [[DefineOwnProperty]]
                </td>
                <td>
                  (_propertyKey_, _PropertyDescriptor_) <b>&rarr;</b> Boolean
                </td>
                <td>
                  创建或者改变 key 值为 _propertyKey_ 的自身属性状态为 _PropertyDescriptor_。返回 true 表示属性被成功创建/更新，返回 false 表示属性不能被创建/更新。
                </td>
              </tr>
              <tr>
                <td>
                  [[HasProperty]]
                </td>
                <td>
                  (_propertyKey_) <b>&rarr;</b> Boolean
                </td>
                <td>
                  返回一个 Boolean 值，代表这个对象自身或者继承了一个 key 值为 _propertyKey_ 的属性。
                </td>
              </tr>
              <tr>
                <td>
                  [[Get]]
                </td>
                <td>
                  (_propertyKey_, _Receiver_) <b>&rarr;</b> <em>any</em>
                </td>
                <td>
                  返回这个对象里 key 值为 _propertyKey_ 的属性的值。如果必须运行一些的 ECMAScript 代码来检索这个属性值，_Receiver_ 就会作为解析代码时的 *this* 值。
                </td>
              </tr>
              <tr>
                <td>
                  [[Set]]
                </td>
                <td>
                  (_propertyKey_, _value_, _Receiver_) <b>&rarr;</b> Boolean
                </td>
                <td>
                  设置这个对象 key 值为 _propertyKey_ 的属性的值为 _value_。如果必须运行一些的 ECMAScript 代码来检索这个属性值，_Receiver_ 就会作为解析代码时的 *this* 值。返回 *true* 表示这个属性值已经设置，返回 *false* 表示不能被设置。
                </td>
              </tr>
              <tr>
                <td>
                  [[Delete]]
                </td>
                <td>
                  (_propertyKey_) <b>&rarr;</b> Boolean
                </td>
                <td>
                  移除这个对象 key 值为 _propertyKey_ 的自身属性。 如果这个属性没有被移除，仍然存在，则返回 *false*。 如果属性被移除，或不存在，则返回 *true*。
                </td>
              </tr>
              <tr>
                <td>
                  [[OwnPropertyKeys]]
                </td>
                <td>
                  ( ) <b>&rarr;</b> List of propertyKey
                </td>
                <td>
                  返回一个包含所有自身属性 key 值的 List。
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
        <p>表 <emu-xref href="#table-6"></emu-xref> 总结了用来支持对象被作为函数调用的其他基础内部方法。 <dfn id="function-object">函数对象</dfn>是支持内部方法 [[Call]] 的对象。 <dfn id="constructor">构造器</dfn>（也叫作<em>构造函数</em>）是支持内部方法 [[Construct]] 的函数对象。</p>
        <emu-table id="table-6" caption="Additional Essential Internal Methods of Function Objects">
          <table>
            <tbody>
              <tr>
                <th>
                  Internal Method
                </th>
                <th>
                  Signature
                </th>
                <th>
                  Description
                </th>
              </tr>
              <tr>
                <td>
                  [[Call]]
                </td>
                <td>
                  (<em>any</em>, a List of <em>any</em>) <b>&rarr;</b> <em>any</em>
                </td>
                <td>
                  执行这个对象相关联的代码。通过一个函数表达式来调用。通过调用表达式，传递给内部函数的 arguments 为一个 *this* 值，和一个包含传递给函数的参数列表，实现该内部方法的对象是<em>可调用的</em>
                </td>
              </tr>
              <tr>
                <td>
                  [[Construct]]
                </td>
                <td>
                  (a List of <em>any</em>, Object) <b>&rarr;</b> Object
                </td>
                <td>
                  创建一个对象。通过 `new` 或者 `super` 操作符调用。这个内部方法的第一个参数是一个包含操作符的参数的列表。第二个参数是 `new` 操作符初始化时应用的对象。实现这个内部方法的对象被称为<em>构造函数</em>。一个函数对象不一定是构造函数，这样的非构造函数的函数对象没有 [[Construct]] 内部方法。
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
        <p>这些普通对象和标准的怪异对象的基础内部方法语义在<emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>指出。如果怪异对象的任何特定内部方法不被实现支持，那么在尝试使用时，必须抛出一个 *TypeError* 异常。</p>
      </emu-clause>

      <!-- es6num="6.1.7.3" -->
      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1><abbr title="Invariants of the Essential Internal Methods">基本内部方法的不变量</abbr></h1>
        <p>ECMAScript 引擎中的内部方法必须符合以下指定的不变量列表。普通 ECMAScript 对象以及该规范中的标准怪异对象应保持这些不变量。ECMAScript Proxy 对象通过运行时检查 [[ProxyHandler]] 对象的<abbr title="traps invoked">陷阱调用</abbr>结果的手段来保持这些不变量。</p>
        <p>任何实现提供的怪异对象必须也保持这些不变量。违反这些不变量可能会导致 ECMAScript 代码出现不可预料的行为以及安全问题。然而，对于造成内存安全的违反不变量行为的实现决不能妥协。</p>
        <p>实现不允许通过任何方式规避这些不变量。比如，通过提供替代接口来实现基本内部方法的功能而不强制执行他们的不变量。</p>
        <h2>定义:</h2>
        <ul>
          <li>
            内部方法的 <em>target</em> 是调用这个内部方法的对象。
          </li>
          <li>
            如果 target 的 [[IsExtensible]] 内部方法返回值是 false 或者 [[PreventExtensions]] 内部方法返回值是 true，那么这个 target 是<em><abbr title="non-extensible">不可扩展的</abbr></em>
          </li>
          <li>
            一个<em><abbr title="non-existent">不存在的</abbr></em>属性是指一个不可扩展的 target 的自身属性中不存在的属性。
          </li>
          <li>
            所有对 <em>SameValue</em> 的引用都是根据 SameValue 算法定义的。
          </li>
        </ul>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            返回的类型必须是 Object 或者 Null。
          </li>
          <li>
            如果 target 是不可扩展的，并且 [[GetPrototypeOf]] 返回了一个值 v，那么任何将来对 [[GetPrototypeOf]] 的调用都应该返回与 v 相同的 SameValue。
          </li>
        </ul>
        <emu-note>
          <p>对象的原型链的长度应该是有限的（也就是说，从任意对象开始，递归地对结果应用 [[GetPrototypeOf]] 内置方法最终应该得到 null）。但是，如果原型链包含任何不使用 [[GetPrototypeOf]] 的普通对象定义的奇异对象，则此要求不强制作为对象级不变量。这样的环形原型链可能会在访问对象属性时产生无限循环。</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] (_V_)</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            如果 target 是不可扩展的，[[SetPrototypeOf]] 必须返回 false，除非 V 与 target 执行 [[GetPrototypeOf]] 内置方法的 SameValue 相同。
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            如果 [[IsExtensible]] 返回 false，所有将来对 target 的 [[IsExtensible]] 内置方法调用都必须返回 false。
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            如果 [[PreventExtensions]] 返回 false，所有将来对 target 的 [[IsExtensible]] 内置方法的的调用都必须返回 false，并且此刻开始 target 被认为是不可扩展的。
          </li>
        </ul>
        <h2>[[GetOwnProperty]] (_P_)</h2>
        <ul>
          <li>
            返回的类型必须是 Property Descriptor 或者 Undefined。
          </li>
          <li>
            如果返回的类型是 Property Descriptor，那么返回值必须是一个完整的 property descriptor (见<emu-xref href="#sec-completepropertydescriptor"></emu-xref>)。
          </li>
          <li>
            一个属性 P 被数据属性 Desc 描述，如果 Desc.[[Value]] 等于 v，且 Desc.[[Writable]] 以及 Desc.[[Configurable]] 都为 false，那么所有将来调用 [[GetOwnProperty]](P) 内置方法时，返回的 SameValue 必须是属性的 Desc.[[Value]]。
          </li>
          <li>
            如果 P 属性除了 [[Writable]] 特性，其他特性在将来可能变化，或者属性可能消失，那么 P 的 [[Configurable]] 特性必须为 true。
          </li>
          <li>
            如果 P 属性的 [[Writable]] 特性可能从 false 变为 true，那么 [[Configurable]] 特性必须为 true。
          </li>
          <li>
            如果对象是不可扩展的且 P 属性不存在，那么将来所有对 target 的 [[GetOwnProperty]] (P) 内置方法的调用必须描述 P 属性不存在（即 [[GetOwnProperty]] (P) 必须返回 undefined）。
          </li>
        </ul>
        <emu-note>
          <p>作为第三个不变量的推论，如果一个属性被描述为一个数据属性并且随着时间它可能返回不同的值，那么 Desc.[[Writable]] 和 Desc.[[Configurable]] 特性必须是 true，虽然没有机制通过其它内置方法去改变暴露出来的值。</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] (_P_, _Desc_)</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            <p>
              如果 P 预先已经作为 target 的一个不可配置的自身属性被观察，那么 [[DefineOwnProperty]] 必须返回 false，除非满足一下条件之一：
            </p>
            <ol>
              <li>
                P 是一个不可配置的可写数据属性。一个不可配置的可写数据属性可以被转换为一个不可配置不可写的数据属性。
              </li>
              <li>
                Desc 中的所有特性都是作为 P 属性特性的 SameValue。
              </li>
            </ol>
          </li>
          <li>
            如果 target 是不可配置的且 P 属性不存在，那么 [[DefineOwnProperty]] (P, Desc) 必须返回 false。也就是说，一个不可配置的 target 对象不能扩展新属性。
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            如果 target 自身属性 P 预先已经作为一个不可配置的数据属性或者访问器属性被观察，[[HasProperty]] 必须返回 true。
          </li>
        </ul>
        <h2>[[Get]] (_P_, _Receiver_)</h2>
        <ul>
          <li>
            如果 P，其值为 V，预先作为一个不可配置，不可写的 target 自身属性被观察，那么 [[GET]] 必须返回 SameValue。
          </li>
          <li>
            如果 P，其 [[Get]] 特性为 undefined，预先作为一个不可配置的 target 自身访问器属性被观察，那么 [[Get]] 操作必须返回 undefined。
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_)</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            如果 P 预先作为一个不可配置，不可写的 target 自身数据属性被观察，那么 [[Set]] 必须返回 false。除非 V 是 P 的 [[Value]] 特性的 SameValue。
          </li>
          <li>
            如果 P，其 [[Set]] 特性为 undefined，预先作为一个不可配置的 target 自身访问器属性被观察，那么 [[Set]] 操作必须返回 false。
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            返回的类型必须是 Boolean。
          </li>
          <li>
            如果 P 预先作为一个不可配置的 target 自身数据或访问器属性被观察，那么 [[Delete]] 必须返回 false。
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            返回值必须是一个 List。
          </li>
          <li>
            返回的列表不能包含任何重复的元素。
          </li>
          <li>
            返回的 List 的每个元素类型为 String 或者 Symbol。
          </li>
          <li>
            返回的 List 必须包含至少预先已经被观察的自身属性的所有不可配置的 key。
          </li>
          <li>
            如果对象是不可扩展的，那么返回的 List 必须只包含使用 [[GetOwnProperty]] 观察的对象所有属性的 key。
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            返回值类型必须是 Object。
          </li>
        </ul>
      </emu-clause>

      <!-- es6num="6.1.7.4" -->
      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>著名<abbr title="Intrinsic Objects">内部对象</abbr></h1>
        <p>著名内联函数是在该规范中通过算法明确引用的内置对象，这些内置对象通常有特定域的不变量。除非特别指出，每个内部对象在每个领域通常对应一系列相似对象的集合。</p>
        <p>在本规范中像 %name% 这样的引用意味着关联到相应的 name 域的内部对象。决定当前域以及他的内联函数在<emu-xref href="#sec-execution-contexts"></emu-xref>描述。著名内联函数在表<emu-xref href="#table-7"></emu-xref>列出。
        </p>
        <emu-table id="table-7" caption="Well-known Intrinsic Objects">
          <table>
            <tbody>
              <tr>
                <th>
                  内在名称
                </th>
                <th>
                  全局名称
                </th>
                <th>
                  ECMAScript 语言关联
                </th>
              </tr>
              <tr>
                <td>
                  %Array%
                </td>
                <td>
                  `Array`
                </td>
                <td>
                  `Array` 构造函数 (<emu-xref href="#sec-array-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayBuffer%
                </td>
                <td>
                  `ArrayBuffer`
                </td>
                <td>
                  `ArrayBuffer` 构造函数 (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayBufferPrototype%
                </td>
                <td>
                  `ArrayBuffer.prototype`
                </td>
                <td>
                  %ArrayBuffer% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayIteratorPrototype%
                </td>
                <td>
                </td>
                <td>
                  数组迭代器对象的原型 (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayPrototype%
                </td>
                <td>
                  `Array.prototype`
                </td>
                <td>
                  %Array% `prototype` 数据属性的初始值 (<emu-xref href="#sec-properties-of-the-array-prototype-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayProto_entries%
                </td>
                <td>
                  `Array.prototype.entries`
                </td>
                <td>
                  %ArrayPrototype% `entries` 数据属性的初始值 (<emu-xref href="#sec-array.prototype.entries"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayProto_forEach%
                </td>
                <td>
                  `Array.prototype.forEach`
                </td>
                <td>
                  %ArrayPrototype% `forEach` 数据属性的初始值 (<emu-xref href="#sec-array.prototype.foreach"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayProto_keys%
                </td>
                <td>
                  `Array.prototype.keys`
                </td>
                <td>
                  %ArrayPrototype% `keys` 数据属性的初始值 (<emu-xref href="#sec-array.prototype.keys"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ArrayProto_values%
                </td>
                <td>
                  `Array.prototype.values`
                </td>
                <td>
                  %ArrayPrototype% `values` 数据属性的初始值 (<emu-xref href="#sec-array.prototype.values"></emu-xref>)                  
                </td>
              </tr>
              <tr>
                <td>
                  %AsyncFunction%
                </td>
                <td>
                </td>
                <td>
                  async 函数对象的构造器 (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %AsyncFunctionPrototype%
                </td>
                <td>
                </td>
                <td>
                  %AsyncFunction% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Atomics%
                </td>
                <td>
                  `Atomics`
                </td>
                <td>
                  `Atomics` 对象 (<emu-xref href="#sec-atomics-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Boolean%
                </td>
                <td>
                  `Boolean`
                </td>
                <td>
                  `Boolean` 构造函数 (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %BooleanPrototype%
                </td>
                <td>
                  `Boolean.prototype`
                </td>
                <td>
                  %Boolean% `prototype` 数据属性的初始值 (<emu-xref href="#sec-properties-of-the-boolean-prototype-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %DataView%
                </td>
                <td>
                  `DataView`
                </td>
                <td>
                  `DataView` 构造函数 (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %DataViewPrototype%
                </td>
                <td>
                  `DataView.prototype`
                </td>
                <td>
                  %DataView% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Date%
                </td>
                <td>
                  `Date`
                </td>
                <td>
                  `Date` 构造函数 (<emu-xref href="#sec-date-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %DatePrototype%
                </td>
                <td>
                  `Date.prototype`
                </td>
                <td>
                  %Date% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %decodeURI%
                </td>
                <td>
                  `decodeURI`
                </td>
                <td>
                  `decodeURI` 函数 (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %decodeURIComponent%
                </td>
                <td>
                  `decodeURIComponent`
                </td>
                <td>
                  `decodeURIComponent` 函数 (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %encodeURI%
                </td>
                <td>
                  `encodeURI`
                </td>
                <td>
                  `encodeURI` 函数 (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %encodeURIComponent%
                </td>
                <td>
                  `encodeURIComponent`
                </td>
                <td>
                  `encodeURIComponent` 函数 (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Error%
                </td>
                <td>
                  `Error`
                </td>
                <td>
                  `Error` 构造函数 (<emu-xref href="#sec-error-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ErrorPrototype%
                </td>
                <td>
                  `Error.prototype`
                </td>
                <td>
                  %Error% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %eval%
                </td>
                <td>
                  `eval`
                </td>
                <td>
                  `eval` 函数 (<emu-xref href="#sec-eval-x"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %EvalError%
                </td>
                <td>
                  `EvalError`
                </td>
                <td>
                  `EvalError` 构造函数 (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %EvalErrorPrototype%
                </td>
                <td>
                  `EvalError.prototype`
                </td>
                <td>
                  %EvalError% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Float32Array%
                </td>
                <td>
                  `Float32Array`
                </td>
                <td>
                  `Float32Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Float32ArrayPrototype%
                </td>
                <td>
                  `Float32Array.prototype`
                </td>
                <td>
                  %Float32Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Float64Array%
                </td>
                <td>
                  `Float64Array`
                </td>
                <td>
                  `Float64Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Float64ArrayPrototype%
                </td>
                <td>
                  `Float64Array.prototype`
                </td>
                <td>
                  %Float64Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Function%
                </td>
                <td>
                  `Function`
                </td>
                <td>
                  `Function` 构造函数 (<emu-xref href="#sec-function-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %FunctionPrototype%
                </td>
                <td>
                  `Function.prototype`
                </td>
                <td>
                  %Function% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Generator%
                </td>
                <td>
                </td>
                <td>
                  %GeneratorFunction% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %GeneratorFunction%
                </td>
                <td>
                </td>
                <td>
                  generator 对象的构造函数 (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %GeneratorPrototype%
                </td>
                <td>
                </td>
                <td>
                  %Generator% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Int8Array%
                </td>
                <td>
                  `Int8Array`
                </td>
                <td>
                  `Int8Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Int8ArrayPrototype%
                </td>
                <td>
                  `Int8Array.prototype`
                </td>
                <td>
                  %Int8Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Int16Array%
                </td>
                <td>
                  `Int16Array`
                </td>
                <td>
                  `Int16Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Int16ArrayPrototype%
                </td>
                <td>
                  `Int16Array.prototype`
                </td>
                <td>
                  %Int16Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Int32Array%
                </td>
                <td>
                  `Int32Array`
                </td>
                <td>
                  `Int32Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Int32ArrayPrototype%
                </td>
                <td>
                  `Int32Array.prototype`
                </td>
                <td>
                  %Int32Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %isFinite%
                </td>
                <td>
                  `isFinite`
                </td>
                <td>
                  `isFinite` 函数 (<emu-xref href="#sec-isfinite-number"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %isNaN%
                </td>
                <td>
                  `isNaN`
                </td>
                <td>
                  `isNaN` 函数 (<emu-xref href="#sec-isnan-number"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %IteratorPrototype%
                </td>
                <td>
                </td>
                <td>
                  所有标准内置迭代对象间接继承的对象
                </td>
              </tr>
              <tr>
                <td>
                  %JSON%
                </td>
                <td>
                  `JSON`
                </td>
                <td>
                  `JSON` 对象 (<emu-xref href="#sec-json-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %JSONParse%
                </td>
                <td>
                  `JSON.parse`
                </td>
                <td>
                  %JSON% `parse` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Map%
                </td>
                <td>
                  `Map`
                </td>
                <td>
                  `Map` 构造函数 (<emu-xref href="#sec-map-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %MapIteratorPrototype%
                </td>
                <td>
                </td>
                <td>
                  Map 迭代器对象的原型 (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %MapPrototype%
                </td>
                <td>
                  `Map.prototype`
                </td>
                <td>
                  %Map% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Math%
                </td>
                <td>
                  `Math`
                </td>
                <td>
                  `Math` 对象 (<emu-xref href="#sec-math-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Number%
                </td>
                <td>
                  `Number`
                </td>
                <td>
                  `Number` 构造函数 (<emu-xref href="#sec-number-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %NumberPrototype%
                </td>
                <td>
                  `Number.prototype`
                </td>
                <td>
                  %Number% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Object%
                </td>
                <td>
                  `Object`
                </td>
                <td>
                  `Object` 构造函数 (<emu-xref href="#sec-object-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ObjectPrototype%
                </td>
                <td>
                  `Object.prototype`
                </td>
                <td>
                  %Object%. (<emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>) `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %ObjProto_toString%
                </td>
                <td>
                  `Object.prototype.toString`
                </td>
                <td>
                  %ObjectPrototype% (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) `toString` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %ObjProto_valueOf%
                </td>
                <td>
                  `Object.prototype.valueOf`
                </td>
                <td>
                  %ObjectPrototype% (<emu-xref href="#sec-object.prototype.valueof"></emu-xref>) `valueOf` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %parseFloat%
                </td>
                <td>
                  `parseFloat`
                </td>
                <td>
                  `parseFloat` 函数 (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %parseInt%
                </td>
                <td>
                  `parseInt`
                </td>
                <td>
                  `parseInt` 函数 (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Promise%
                </td>
                <td>
                  `Promise`
                </td>
                <td>
                  `Promise` 构造函数 (<emu-xref href="#sec-promise-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %PromisePrototype%
                </td>
                <td>
                  `Promise.prototype`
                </td>
                <td>
                  %Promise% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %PromiseProto_then%
                </td>
                <td>
                  `Promise.prototype.then`
                </td>
                <td>
                  The initial value of the `then` data property of %PromisePrototype% (<emu-xref href="#sec-promise.prototype.then"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Promise_all%
                </td>
                <td>
                  `Promise.all`
                </td>
                <td>
                  The initial value of the `all` data property of %Promise% (<emu-xref href="#sec-promise.all"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Promise_reject%
                </td>
                <td>
                  `Promise.reject`
                </td>
                <td>
                  The initial value of the `reject` data property of %Promise% (<emu-xref href="#sec-promise.reject"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Promise_resolve%
                </td>
                <td>
                  `Promise.resolve`
                </td>
                <td>
                  The initial value of the `resolve` data property of %Promise% (<emu-xref href="#sec-promise.resolve"></emu-xref>)  
                </td>
              </tr>
              <tr>
                <td>
                  %Proxy%
                </td>
                <td>
                  `Proxy`
                </td>
                <td>
                  `Proxy` 构造函数 (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %RangeError%
                </td>
                <td>
                  `RangeError`
                </td>
                <td>
                  `RangeError` 构造函数 (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %RangeErrorPrototype%
                </td>
                <td>
                  `RangeError.prototype`
                </td>
                <td>
                  %RangeError% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %ReferenceError%
                </td>
                <td>
                  `ReferenceError`
                </td>
                <td>
                  `ReferenceError` 构造函数 (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %ReferenceErrorPrototype%
                </td>
                <td>
                  `ReferenceError.prototype`
                </td>
                <td>
                  %ReferenceError% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Reflect%
                </td>
                <td>
                  `Reflect`
                </td>
                <td>
                  `Reflect` 对象 (<emu-xref href="#sec-reflect-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %RegExp%
                </td>
                <td>
                  `RegExp`
                </td>
                <td>
                  `RegExp` 构造函数 (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %RegExpPrototype%
                </td>
                <td>
                  `RegExp.prototype`
                </td>
                <td>
                  %RegExp% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Set%
                </td>
                <td>
                  `Set`
                </td>
                <td>
                  `Set` 构造函数 (<emu-xref href="#sec-set-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %SetIteratorPrototype%
                </td>
                <td>
                </td>
                <td>
                  Set 迭代器对象的原型 (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %SetPrototype%
                </td>
                <td>
                  `Set.prototype`
                </td>
                <td>
                  %Set% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %SharedArrayBuffer%
                </td>
                <td>
                  `SharedArrayBuffer`
                </td>
                <td>
                  `SharedArrayBuffer` 构造函数 (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %SharedArrayBufferPrototype%
                </td>
                <td>
                  `SharedArrayBuffer.prototype`
                </td>
                <td>
                  %SharedArrayBuffer% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %String%
                </td>
                <td>
                  `String`
                </td>
                <td>
                  `String` 构造函数 (<emu-xref href="#sec-string-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %StringIteratorPrototype%
                </td>
                <td>
                </td>
                <td>
                  String 迭代器对象的原型 (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %StringPrototype%
                </td>
                <td>
                  `String.prototype`
                </td>
                <td>
                  %String% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Symbol%
                </td>
                <td>
                  `Symbol`
                </td>
                <td>
                  `Symbol` 构造函数 (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %SymbolPrototype%
                </td>
                <td>
                  `Symbol.prototype`
                </td>
                <td>
                  %Symbol% `prototype` 数据属性的初始值 (<emu-xref href="#sec-properties-of-the-symbol-prototype-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %SyntaxError%
                </td>
                <td>
                  `SyntaxError`
                </td>
                <td>
                  `SyntaxError` 构造函数 (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %SyntaxErrorPrototype%
                </td>
                <td>
                  `SyntaxError.prototype`
                </td>
                <td>
                  %SyntaxError% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %ThrowTypeError%
                </td>
                <td>
                </td>
                <td>
                  一个函数对象，无条件的抛出一个新 %TypeError% 实例
                </td>
              </tr>
              <tr>
                <td>
                  %TypedArray%
                </td>
                <td>
                </td>
                <td>
                  所有数组类型构造器的超类 (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %TypedArrayPrototype%
                </td>
                <td>
                </td>
                <td>
                  %TypedArray% `prototype 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %TypeError%
                </td>
                <td>
                  `TypeError`
                </td>
                <td>
                  `TypeError` 构造函数 (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %TypeErrorPrototype%
                </td>
                <td>
                  `TypeError.prototype`
                </td>
                <td>
                  %TypeError% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Uint8Array%
                </td>
                <td>
                  `Uint8Array`
                </td>
                <td>
                  `Uint8Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Uint8ArrayPrototype%
                </td>
                <td>
                  `Uint8Array.prototype`
                </td>
                <td>
                  %Uint8Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Uint8ClampedArray%
                </td>
                <td>
                  `Uint8ClampedArray`
                </td>
                <td>
                  `Uint8ClampedArray` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Uint8ClampedArrayPrototype%
                </td>
                <td>
                  `Uint8ClampedArray.prototype`
                </td>
                <td>
                  %Uint8ClampedArray% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Uint16Array%
                </td>
                <td>
                  `Uint16Array`
                </td>
                <td>
                  `Uint16Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Uint16ArrayPrototype%
                </td>
                <td>
                  `Uint16Array.prototype`
                </td>
                <td>
                  %Uint16Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %Uint32Array%
                </td>
                <td>
                  `Uint32Array`
                </td>
                <td>
                  `Uint32Array` 构造函数 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %Uint32ArrayPrototype%
                </td>
                <td>
                  `Uint32Array.prototype`
                </td>
                <td>
                  %Uint32Array% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %URIError%
                </td>
                <td>
                  `URIError`
                </td>
                <td>
                  `URIError` 构造函数 (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %URIErrorPrototype%
                </td>
                <td>
                  `URIError.prototype`
                </td>
                <td>
                  %URIError% `prototype` 属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %WeakMap%
                </td>
                <td>
                  `WeakMap`
                </td>
                <td>
                  `WeakMap` 构造函数 (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %WeakMapPrototype%
                </td>
                <td>
                  `WeakMap.prototype`
                </td>
                <td>
                  %WeakMap% `prototype` 数据属性的初始值
                </td>
              </tr>
              <tr>
                <td>
                  %WeakSet%
                </td>
                <td>
                  `WeakSet`
                </td>
                <td>
                  `WeakSet` 构造函数 (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
                </td>
              </tr>
              <tr>
                <td>
                  %WeakSetPrototype%
                </td>
                <td>
                  `WeakSet.prototype`
                </td>
                <td>
                  %WeakSet% `prototype` 数据属性的初始值
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>